package com.security.app.crypto.service;
/**
 *  SymmetricEncryptionUtility for client and server architect
 *  encrypt and decrypt message by AES algorithm , Cipher Block Chain(CBC) and automatic padding message. become
 *  multiple of 16 (PK5padding), java built in method Cipher.getInstance("AES/CBC/PKCS5Padding");
 *  this is higher level AES cipher algorithm, before this block is encrypted, CBC always XOR previous encrypted block.
 *  the key is generated by SecretKeySpec(key, "AES"); key will be byte[] which must be 16 bytes
 *  if user apply key without 16 bytes, we create standardizeKey method to pad it to 16 bytes.
 *  client side call constructor SymmetricEncryptionUtility() to generate key. iv and encoded seedStr4IV (initialized vector)
 *  to encrypt meesage
 *  server side call constructor SymmetricEncryptionUtility(String seedStr4IV) to recover the IV which encrypt method used
 *  
 */
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.logging.log4j.Logger;
 
import com.mailfrontier.msgcenter.app.log.Logger;
 
public class EncryptionUtils {
	public static Logger Log =Logger.getLogger(EncryptionUtils.class.getName()); 
	//private IvParameterSpec initialVector;
	private String seedStr4IV=null;
  
	private Cipher encryptCipher =null;
	private Cipher decryptCipher =null;
	/**
	 *  Message to be digested
	 */
    public final static String DIGEST_MESSAGE_STRING = "sonicwall40%dsgsonicwall40345234214%ds12345678";

	private final static String KEY_STRING="456f!@#!@#dgdg5756771bcbvhe!@@#!3442112123";
	private final static int MULTIPLE = 16;	// Block is 128 bits and 16 bytes		
	public  final static  String AUTH_FAILED = "Auth_Failed";
	public  final static  String AUTH_PASSED = "Auth_Passed";
	public final static String CHAR_SET = "ISO-8859-1";
	/**
	 * In order to ensure thread safe and eliminate the lazy initialization.
	 * We create instance at class loading time when tomcat starting
	 * @author jzhang
	 *
	 */
 
	private static class Holder {
	    static final EncryptionUtils INSTANCE = new EncryptionUtils();
	}

	public static EncryptionUtils getInstance() { // for client
	    return Holder.INSTANCE;
	}
	  
	 
	
	private EncryptionUtils() { // only for request client 
		  synchronized(this) { // Tested: Sometimes , this block running 13 seconds, therefore we must synchronized it
			  Log.info("Begin");
			 	 
			  SecretKeySpec skey = AESCipherUtil.getInstance().getSkey();
			 
			  SecureRandom random = new SecureRandom();
			 
			  byte [] seed = random.generateSeed(16);
			 
			  IvParameterSpec initialVector = new IvParameterSpec(seed);
			 
			  seedStr4IV =Base64.encodeBase64String(seed);
			  
			  try {
				  encryptCipher= Cipher.getInstance("AES/CBC/PKCS5Padding");
				  encryptCipher.init(Cipher.ENCRYPT_MODE,skey,initialVector);							  
				  decryptCipher= Cipher.getInstance("AES/CBC/PKCS5Padding");
				  decryptCipher.init(Cipher.DECRYPT_MODE,skey,initialVector);
				  
			  } catch (Exception e) {
				  Log.info("Failed to initialize Cipher");
			  }
			  
			  Log.info("End");
		  }
	}	 
	
	 
	
	public EncryptionUtils(String seedStr4IV) {	// only for accept request server
		 synchronized(this) { // Tested: Sometimes , this block running 13 seconds, therefore we must synchronized it
			 
			 this.seedStr4IV = seedStr4IV;
			 
			 byte [] seedServer  = Base64.decodeBase64(seedStr4IV);
			 
			 IvParameterSpec initialVector = new IvParameterSpec(seedServer);			 
			 
			 SecretKeySpec skey =AESCipherUtil.getInstance().getSkey();
			 
			 try {
				  encryptCipher= Cipher.getInstance("AES/CBC/PKCS5Padding");
				  encryptCipher.init(Cipher.ENCRYPT_MODE,skey,initialVector);							  
				  decryptCipher= Cipher.getInstance("AES/CBC/PKCS5Padding");
				  decryptCipher.init(Cipher.DECRYPT_MODE, skey,initialVector);
				  
			  } catch (Exception e) {
				  Log.info("Failed to initialize Cipher");
			  }
			 
		 }
	}		
 
	public synchronized String encrypt(final String message) throws IllegalBlockSizeException,
		BadPaddingException, NoSuchAlgorithmException,
		NoSuchPaddingException, InvalidKeyException,
		UnsupportedEncodingException, InvalidAlgorithmParameterException {
		 
		byte[] stringBytes = message.getBytes();

		byte[] raw = encryptCipher.doFinal(stringBytes);

		return Base64.encodeBase64String(raw);
	}
  
	public synchronized String decrypt(final String encrypted) throws InvalidKeyException,
		NoSuchAlgorithmException, NoSuchPaddingException,
		IllegalBlockSizeException, BadPaddingException, IOException, InvalidAlgorithmParameterException {
		
		byte[] raw = Base64.decodeBase64(encrypted);

		byte[] stringBytes =  decryptCipher.doFinal(raw);

		String clearText = new String(stringBytes, CHAR_SET);
		return clearText;
	}
	
	
	public synchronized String getHexdigestMsgBySha256(String inputData) throws NoSuchAlgorithmException,
		NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException,
		UnsupportedEncodingException, InvalidAlgorithmParameterException {
		MessageDigest md = MessageDigest.getInstance("SHA-256");
		md.update(inputData.getBytes(CHAR_SET)); 
		byte[] bytes = md.digest();
	return new String (bytesToHex(bytes));
	}	
	
	private static String bytesToHex(byte[] bytes) {
	    StringBuffer result = new StringBuffer();
	    for (byte byt : bytes) result.append(Integer.toString((byt &0xff) + 0x100, 16).substring(1));
	    return result.toString();
	 }
	public String userAuthentication(MessageAuthVO vo) throws Exception {
		
		String descryptedMessage = decrypt(vo.getEncryptedMessage());
		String hash1 = vo.getHashedMessage();
		String hash2 = getHexdigestMsgBySha256(descryptedMessage);
		String retVal = AUTH_FAILED;
		Log.info("hash1="+hash1+",hash2= "+hash2+",decrypted message="+descryptedMessage);
		if (hash1.equalsIgnoreCase(hash2)) {
			retVal= AUTH_PASSED;
		}
		return retVal;
		
	}
	public String userAuthentication(NewMessageAuthVO vo) throws Exception {
		
		String descryptedMessage = decrypt(vo.getEncryptedMessage());
		String hash1 = vo.getHashedMessage();
		String hash2 = getHexdigestMsgBySha256(descryptedMessage);
		String retVal = AUTH_FAILED;
		Log.debug("hash1="+hash1+",hash2= "+hash2+",decrypted message="+descryptedMessage);
		if (hash1.equalsIgnoreCase(hash2)) {
			retVal= AUTH_PASSED;
		}
		return retVal;
		
	}
	public String getseedStr4IV() {
		return seedStr4IV;
	}
 
	
	public static void main(String[] args) throws Exception{

	  EncryptionUtils handler = new EncryptionUtils();
      
      String clearText = "hello world, Dear Yvonne, I love you!";
      Log.info("Clear Text:" + clearText);
      String encryptedString = handler.encrypt(clearText);
      
      String seedStr4IV = handler.getseedStr4IV();
      
      handler = new EncryptionUtils(seedStr4IV);
      
      
      Log.info("Encrypted String:" + encryptedString);

      Log.info("Decrypted String:"+handler.decrypt(encryptedString));
      }

}

