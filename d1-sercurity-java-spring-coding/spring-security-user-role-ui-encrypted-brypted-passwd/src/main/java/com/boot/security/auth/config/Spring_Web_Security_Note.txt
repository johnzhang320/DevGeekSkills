----------------------------------------------docs.spring.io Spring Security Community--------------------------------------------------------
Part I. Getting Started
https://docs.spring.io/spring-security/site/docs/3.0.x/reference/community.html

Core Services
Part II. Architecture and Implementation
https://docs.spring.io/spring-security/site/docs/3.0.x/reference/core-services.html

Part III. Web Application Security
https://docs.spring.io/spring-security/site/docs/3.0.x/reference/web-app-security.html

Authorization Architecture
 Part IV. Authorization
https://docs.spring.io/spring-security/site/docs/3.0.x/reference/authz-arch.html

JSP Authentication /Authorize Taglib
https://docs.spring.io/spring-security/site/docs/3.0.x/reference/taglibs.html

Appendix A. Security Database Schema

https://docs.spring.io/spring-security/site/docs/3.0.x/reference/appendix-schema.html

---------------------------------------------------------docs.spring.io User Schema------------------------------------------------------------------------------------------
The standard JDBC implementation of the UserDetailsService (JdbcDaoImpl) requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user.

  create table users(
      username varchar_ignorecase(50) not null primary key,
      password varchar_ignorecase(50) not null,
      enabled boolean not null);

  create table authorities (
      username varchar_ignorecase(50) not null,
      authority varchar_ignorecase(50) not null,
      constraint fk_authorities_users foreign key(username) references users(username));
      create unique index ix_auth_username on authorities (username,authority);
A.1.1 Group Authorities

Spring Security 2.0 introduced support for group authorities in JdbcDaoImpl. The table structure if groups are enabled is as follows:

create table groups (
  id bigint generated by default as identity(start with 0) primary key,
  group_name varchar_ignorecase(50) not null);

create table group_authorities (
  group_id bigint not null,
  authority varchar(50) not null,
  constraint fk_group_authorities_group foreign key(group_id) references groups(id));

create table group_members (
  id bigint generated by default as identity(start with 0) primary key,
  username varchar(50) not null,
  group_id bigint not null,
  constraint fk_group_members_group foreign key(group_id) references groups(id));
        

--------------------------------------------------------WebSecurityConfigurerAdapter(1)-------------------------------------------------------------------------------------------

Specifying URLs
The most common approach to specifying a URL is through antMatchers. So if we want to secure:

http://www.example.com/static	Open to everyone – CSS, JavaScript
http://www.example.com/register	Open to everyone
http://www.example.com/login	Open to everyone
http://www.example.com/user/	ROLE_USER or ROLE_ADMIN – User Area
http://www.example.com/admin/	
ROLE_ADMIN only and restrict on IPADDRESS – Admin Area

We would simply use:
.antMatchers("/register");

Or with multiple:
.antMatchers("/register","/login","/user","/admin")

We also specify individual pages or directories –
.antMatchers("register.html"); // Individual
.antMatchers("/admin/**"); // Directory

Securing the URLs
The methods to secure URL’s are defined in AuthorizedUrl. The most common methods are:
authenticated(): This is the URL you want to protect, and requires the user to login

permitAll(): This is used for URL’s with no security applied for example css, javascript

hasRole(String role): Restrict to single role. Note that the role will have “ROLE_” appended. 
So role=”ADMIN” has a comparison against “ROLE_ADMIN”. An alternatve is hasAuthority(String authority)

hasAnyRole(String… roles): Allows multiple roles. An alternative is hasAnyAuthority(String… authorities)

Other useful methods are:
access(String attribute): This method takes SPEL, so you can create more complex restrictions. 
For those who are interested a lot of the methods in  ExpressionUrlAuthorizationConfigurer.
AuthorizedUrl ultimately call access with the required SPEL
hasIpAddress(String ipaddressExpression): Restrict on IP address or subnet

Putting it All Together
We can put this all together and create a method like:

    @Override
    protected void configure(HttpSecurity http) throws Exception {
      http
        .authorizeRequests()
           .antMatchers("/static","/register").permitAll()
           .antMatchers("/user/**").hasRoles("USER", "ADMIN") // can pass multiple roles
           .antMatchers("/admin/**").access("hasRole('ADMIN') and hasIpAddress('123.123.123.123')") // pass SPEL using access method
           .anyRequest().authenticated()
           .and()
       .formLogin()
           .loginUrl("/login")
           .permitAll();
    }
The key points are:

permitAll gives everyone access to a file or directory.
hasRoles passes multiple roles.

access for more complicated access.
As a side note, I am currently working on a project to automatically generate this configuration with my spring-security-generator.

--------------------------------------------------------WebSecurityConfigurerAdapter(2)-------------------------------------------------------------------------------------------

I have a requirement to display custom based login form(/auth/login.html) through spring security when user hits
 http://localhost:8080. If user login successfully with admin role, redirect the user to /admin/adminsuccess.html. 
 Once admin user redirected to /adminsuccess.html, I need to permit admin user to access other pages e.g.
  (/admin/assetallocate.html,/admin/assetdeallocate.html..)If user not logging in with admin role, show the 
  same login page with errors..
  
  WebSecurityConfig
  
http.authorizeRequests()
.antMatchers("/login").permitAll()
.antMatchers("/admin/**").access("hasRole('ADMIN')")
.antMatchers("/**").access("hasRole('USER')")
.and()
.formLogin().loginPage("/login")
.usernameParameter("username")
.passwordParameter("password")
.defaultSuccessUrl("/index")
.failureUrl("/login?error");

mport org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;


@Configuration
@ComponentScan(basePackages="com.satya.rab.config")
//@ImportResource({"classpath*:webSecurityConfig.xml"})
@EnableWebSecurity
public class WebSecurityConfig  extends WebSecurityConfigurerAdapter {
	
	@Autowired
	AuthenticationProvider authProvider;
	
	 @Autowired
	    public void configureGlobalSecurity(AuthenticationManagerBuilder auth) throws Exception {
	        auth.authenticationProvider(authProvider);
	    }
	     
	    @Override
	    protected void configure(HttpSecurity http) throws Exception {
	  
	      http.authorizeRequests()
	        //.antMatchers("/login").permitAll()
	        //.antMatchers("/**").access("hasRole('USER')")
                  .antMatchers("/login").permitAll()
                  .antMatchers("/admin/**").access("hasRole('ADMIN')")
                  .antMatchers("/**").access("hasRole('USER')")
                  .and().formLogin().loginPage("/login")
	        .usernameParameter("username").passwordParameter("password").defaultSuccessUrl("/index").failureUrl("/login?error");
	        //.and().exceptionHandling().accessDeniedPage("/accessDenied");
	  
	    }
	
}

--------------------------------------------------------WebSecurityConfigurerAdapter(3)-------------------------------------------------------------------------------------------

You can use a authentication provider of your choice to set roles based on the user.

CustomeAuthenticationProvider

@Component("authProvider")
public class CustomAuthenticationProvider implements AuthenticationProvider     {

@Override
public Authentication authenticate(Authentication auth) throws AuthenticationException {
    String username = auth.getName();
    String password = auth.getCredentials().toString();

    if(username.equals("user") && password.equals("user")) {
        List<GrantedAuthority> grantedAuths = new ArrayList<GrantedAuthority>();
        grantedAuths.add(new SimpleGrantedAuthority("ROLE_USER"));
        return new UsernamePasswordAuthenticationToken(username, password, grantedAuths);
    } else if(username.equals("admin") && password.equals("admin")) {
        List<GrantedAuthority> grantedAuths = new ArrayList<GrantedAuthority>();
        grantedAuths.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
        grantedAuths.add(new SimpleGrantedAuthority("ROLE_USER"));
        return new UsernamePasswordAuthenticationToken(username, password, grantedAuths);
    } else {
        throw new CustomException("Unable to auth against third party systems");
    }
}

@Override
public boolean supports(Class<?> auth) {
    return auth.equals(UsernamePasswordAuthenticationToken.class);
}

--------------------------------------------------------WebSecurityConfigurerAdapter(4)-------------------------------------------------------------------------------------------


Yes. Issue is with your ant matchers.

As per my understanding, when you say anyRequest.permitAll , it doesn't comply with antMatchers("/admin/*").access("hasRole('ROLE_ADMIN')") because you're telling web security to allow every request to go through without authorization.

Change as below,

http.authorizeRequests()
        .antMatchers("/login").permitAll()
        .antMatchers("/admin/**").access("hasRole('ADMIN')")
        .and().formLogin().loginPage("/login")
https://github.com/satya-j/rab/blob/master/src/main/java/com/satya/rab/config/WebSecurityConfig.java - refer to this, its my repo where I had earlier tried out with spring security.

EDIT:

Here is an update

WebSecurityConfig

.antMatchers("/login").permitAll()
.antMatchers("/admin/**").access("hasRole('ADMIN')")
.antMatchers("/**").access("hasRole('USER')")
.and()
.formLogin().loginPage("/login")
.usernameParameter("username")
.passwordParameter("password")
.defaultSuccessUrl("/index")
.failureUrl("/login?error");
You can use a authentication provider of your choice to set roles based on the user.
--------------------------------------------------------WebSecurityConfigurerAdapter(5)-------------------------------------------------------------------------------------------
@Override
protected void configure(final HttpSecurity http) throws Exception {
    ...
    .antMatchers("/auth/admin/*").hasRole("ADMIN")
    .antMatchers("/auth/*").hasAnyRole("ADMIN","USER")
    ...
}

@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
      .withUser("user1").password("user1Pass")
      .authorities("USER")
      .and().withUser("admin").password("adminPass")
      .authorities("ADMIN");
}

--------------------------------------------------Different Role for different URL under One URL directory -----------------------------------------------------------------------------
What I expect here is,


Any request matches to /high_level_url_A/** should be authenticated + 
/high_level_url_A/sub_level_1 only for USER and /high_level_url_A/sub_level_2 only for USER2

Any request matches to /high_level_url_B/** should be authenticated + 
/high_level_url_B/sub_level_1 for public access and /high_level_url_A/sub_level_2 only for USER3.
Any other pattern I don't care - But should be public ?

solution

http
    .authorizeRequests()
        .antMatchers("/high_level_url_A/sub_level_1").hasRole('USER')
        .antMatchers("/high_level_url_A/sub_level_2").hasRole('USER2')
        .somethingElse() // for /high_level_url_A/**
        .antMatchers("/high_level_url_A/**").authenticated()
        .antMatchers("/high_level_url_B/sub_level_1").permitAll()
        .antMatchers("/high_level_url_B/sub_level_2").hasRole('USER3')
        .somethingElse() // for /high_level_url_B/**
        .antMatchers("/high_level_url_B/**").authenticated()
        .anyRequest().permitAll()

--------------------------------------------------antMatcher vs antMathers-----------------------------------------------------------------------------
antMatcher() is a method of HttpSecurity, it doesn't have anything to do with authorizeRequests(). 
Basically, http.antMatcher() tells Spring to only configure HttpSecurity if the path matches this pattern.

The authorizeRequests().antMatchers() is then used to apply authorization to one or more paths you 
specify in antMatchers(). Such as permitAll() or hasRole('USER3'). These only get applied if the first http.antMatcher() is matched.

--------------------------------------------------"/" , "/*" ,"/**"-----------------------------------------------------------------------------

"/" , "/*" ,"/**"
Most important and easiest make mistake mother fucker matcher
"/" --- we permitAll() it first, we have to specify the end point under this "/" , 
       http.authorizeRequest()
       antMatcher("/").permitAll()
       antMatcher("/user/getEmployeeList").hasAnyRole("ADMIN","USER");     // hasAnyRole adding prefix ROLE_ to ADMIN and USER
       
The difference between /* & /** is that the second matches the entire directory tree, including subdirectories,
 where as /* only matches at the level it's specified at.      
       
--------------------------------------------------------Simple api HttpBasic Authentication----------------------------------------------------------------------------------------------------------------------
 In Specific

I want to have HTTP Basic authentication ONLY for a specific URL pattern.

In Detail

I'm creating an API interface for my application and that needs to be authenticated by simple HTTP basic authentication.
 But other web pages should not be using HTTP basic but rather a the normal form login.
 
 
Solution

@Configuration
@EnableWebMvcSecurity
@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true, proxyTargetClass = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter{

    @Autowired
    private AuthenticationProvider authenticationProvider;

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.authenticationProvider(authenticationProvider);
    }

    @Configuration
    @Order(1)
    public static class ApiWebSecurityConfig extends WebSecurityConfigurerAdapter{
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf().disable()
                    .antMatcher("/api/**")
                    .authorizeRequests()
                        .anyRequest().hasAnyRole("ADMIN", "API")
                        .and()
                    .httpBasic();
        }
    }

    @Configuration
    @Order(2)
    public static class FormWebSecurityConfig extends WebSecurityConfigurerAdapter{

        @Override
        public void configure(WebSecurity web) throws Exception {
            web.ignoring().antMatchers("/css/**", "/js/**", "/img/**", "/lib/**");
        }

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf().disable() //HTTP with Disable CSRF
                    .authorizeRequests() //Authorize Request Configuration
                        .antMatchers("/connect/**").permitAll()
                        .antMatchers("/", "/register").permitAll()
                        .antMatchers("/admin/**").hasRole("ADMIN")
                        .anyRequest().authenticated()
                        .and() //Login Form configuration for all others
                    .formLogin()
                        .loginPage("/login").permitAll()
                        .and() //Logout Form configuration
                    .logout().permitAll();
        }
    }
}
 
---------------------------------------------------------Order for WebSecurityConfigurationAdapter multiple times---------------------------------------------------------------------------------------------------------------------

Multiple HttpSecurity

We can configure multiple HttpSecurity instances just as we can have multiple <http> blocks. The key is to 
extend the WebSecurityConfigurationAdapter multiple times. For example, the following is an example of 
having a different configuration for URL’s that start with /api/.

httpBasic means do not 

@EnableWebSecurity
public class MultiHttpSecurityConfig {
  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) { 1
      auth
          .inMemoryAuthentication()
              .withUser("user").password("password").roles("USER").and()
              .withUser("admin").password("password").roles("USER", "ADMIN");
  }

  @Configuration
  @Order(1)                                                        2
  public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
      protected void configure(HttpSecurity http) throws Exception {
          http
              .antMatcher("/api/**")                               3
              .authorizeRequests()
                  .anyRequest().hasRole("ADMIN")
                  .and()
              .httpBasic();
      }
  }    

  @Configuration                                                   4
  public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http
              .authorizeRequests()
                  .anyRequest().authenticated()
                  .and()
              .formLogin();
      }
  }
}

1 Configure Authentication as normal

2 Create an instance of WebSecurityConfigurerAdapter that contains @Order to specify which 
WebSecurityConfigurerAdapter should be considered first.

3 The http.antMatcher states that this HttpSecurity will only be applicable to URLs that start with /api/

4 Create another instance of WebSecurityConfigurerAdapter. If the URL does not start with /api/ this 
configuration will be used. This configuration is considered after ApiWebSecurityConfigurationAdapter 
since it has an @Order value after 1 (no @Order defaults to last).

------------------------------------------------------what is means CSRF------------------------------------------------------------------------------------------------------------------------
Cross-Site Request Forgery (CSRF) in simple words ( Forgery -- pretend and false access or false product)

Assume you are currently logged into your online banking at www.mybank.com
Assume a money transfer from mybank.com will result in a request of (conceptually) the 
form http://www.mybank.com/transfer?to=<SomeAccountnumber>;amount=<SomeAmount>. 
(Your account number is not needed, because it is implied by your login.)
You visit www.cute-cat-pictures.org, not knowing that it is a malicious site.
If the owner of that site knows the form of the above request (easy!) and correctly 
guesses you are logged into mybank.com (requires some luck!), they could include on 
their page a request like http://www.mybank.com/transfer?to=123456;amount=10000 
(where 123456 is the number of their Cayman Islands account and 10000 is an amount 
that you previously thought you were glad to possess).
You retrieved that www.cute-cat-pictures.org page, so your browser will make that request.
Your bank cannot recognize this origin of the request: Your web browser will send the 
request along with your www.mybank.com cookie and it will look perfectly legitimate. There goes your money!
This is the world without CSRF tokens.

Now for the better one with CSRF tokens:

The transfer request is extended with a third argument: 
http://www.mybank.com/transfer?to=123456;amount=10000;token=31415926535897932384626433832795028841971.
That token is a huge, impossible-to-guess random number that mybank.com will include on their own web 
page when they serve it to you. It is different each time they serve any page to anybody.
The attacker is not able to guess the token, is not able to convince your web browser to surrender it
 (if the browser works correctly...), and so the attacker will not be able to create a valid request,
  because requests with the wrong token (or no token) will be refused by www.mybank.com.
Result: You keep your 10000 monetary units. I suggest you donate some of that to Wikipedia.

(Your mileage may vary.)

-----------------------------------------------------------Customize Login page, succussful page , error page-------------------------------------------------------------------------------------------------------------------


@Override
protected void configure(HttpSecurity http) throws Exception {
    http
      .csrf().disable()
      .authorizeRequests()
      .antMatchers("/auth/login*").anonymous()          // / means we have specify  and /* means / directory only  /** means / and all subdirectories of /
      .anyRequest().authenticated()                     // /auth/login* means endpoint of controller service
      .and()
      .formLogin()
      .loginPage("/auth/login")
      .defaultSuccessUrl("/home", true)
      .failureUrl("/auth/login?error=true")
      .and()
      .logout().logoutSuccessUrl("/auth/login");
------------------------------------------------------------John Zhang Put all together with Exception handling------------------------------------------------------------------------------------------------------------------
      protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
        .authorizeRequests()
        .antMatchers("/registration","/getKeyPair.html","/resources/**","/home").permitAll() //GET
        .antMatchers("/safebox/bankaccount.html").hasRole("ADMIN")    // need role ADMIN logins  //GET
        .antMatchers("/safebox/getEmployeesList").hasRole("USER")   //GET
        .antMatchers("/safebox/dashboard.html").hasRole("USER")  // need role USER logins  //GET
        .anyRequest().authenticated()
          .and()
        .formLogin()
            .loginPage("/login")
            .failureUrl("/login?error=true")
            .and()
            .logout().logoutSuccessUrl("/logout") 
            .and()
            .exceptionHandling().accessDeniedHandler(accessDeniedHandler);
        
        http.csrf().disable();
        
    }   
      
------------------------------------------------------------Mkyong Put all together with Exception handling------------------------------------------------------------------------------------------------------------------
   // roles admin allow to access /dashboard/**
    // roles user allow to access /agent/**
    // custom 403 access denied handler
    @Override
    protected void configure(HttpSecurity http) throws Exception {
    	
        http.csrf().disable()
                .authorizeRequests()
                .antMatchers("/", "/home", "/about","/certMain").permitAll()
                .antMatchers("/dashboard/**").hasRole("ADMIN")
                .antMatchers("/agent/**").hasAnyRole("ADMIN","USER")
                 .anyRequest().authenticated()
                 .and()
                .formLogin()
                .loginPage("/login").defaultSuccessUrl("http://localhost:8080/home")
                .permitAll()
                .and()
                .logout()
                .permitAll()
                .and()
                .exceptionHandling().accessDeniedHandler(accessDeniedHandler);
    }    

------------------------------------------------------------CustomeAuthenticationProvider------------------------------------------------------------------------------------------------------------------
CustomeAuthenticationProvider

@Component("authProvider")
public class CustomAuthenticationProvider implements AuthenticationProvider     {

@Override
public Authentication authenticate(Authentication auth) throws AuthenticationException {
    String username = auth.getName();
    String password = auth.getCredentials().toString();

    if(username.equals("user") && password.equals("user")) {
        List<GrantedAuthority> grantedAuths = new ArrayList<GrantedAuthority>();
        grantedAuths.add(new SimpleGrantedAuthority("ROLE_USER"));
        return new UsernamePasswordAuthenticationToken(username, password, grantedAuths);
    } else if(username.equals("admin") && password.equals("admin")) {
        List<GrantedAuthority> grantedAuths = new ArrayList<GrantedAuthority>();
        grantedAuths.add(new SimpleGrantedAuthority("ROLE_ADMIN"));
        grantedAuths.add(new SimpleGrantedAuthority("ROLE_USER"));
        return new UsernamePasswordAuthenticationToken(username, password, grantedAuths);
    } else {
        throw new CustomException("Unable to auth against third party systems");
    }
}

@Override
public boolean supports(Class<?> auth) {
    return auth.equals(UsernamePasswordAuthenticationToken.class);
}
I've used a Custom authentication. As I'm playing with spring security I didn't go for any database configuration. You can implement 
it in your own way. The above validates auth credentials and sets role(authorities). As admin can be able to view user modules as 
well(most cases, at least that's my conception), I've attached authorities user& admin when admin logs in. In simple words, 1. 
When a user log in he'll be able access every /** , but not /admin/** 2. When a admin log in he'll be able access every /** and /admin/**

I've tested the scenarios, and the entire code you can go though here - https://github.com/satya-j/rab

------------------------------------------------------------JSP Authentication /Authorize Taglib------------------------------------------------------------------------------------------------------------------
https://docs.spring.io/spring-security/site/docs/3.0.x/reference/taglibs.html

19. JSP Security Tag Libraries

Spring Security has its own taglib which provides basic support for accessing security information and applying security constraints 
in JSPs.

19.1 Declaring the Taglib

To use any of the tags, you must have the security taglib declared in your JSP:

    <%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
19.2 The authorize Tag

This tag is used to determine whether its contents should be evaluated or not. In Spring Security 3.0, it can be used in two ways [18].
 The first approach uses a web-security expression, specified in the access attribute of the tag. The expression evaluation will be 
 delegated to the WebSecurityExpressionHandler defined in the application context (you should have web expressions enabled in your
  <http> namespace configuration to make sure this service is available). So, for example, you might have

<sec:authorize access="hasRole('supervisor')">

This content will only be visible to users who have
the "supervisor" authority in their list of <tt>GrantedAuthority</tt>s.

</sec:authorize>
A common requirement is to only show a particular link, if the user is actually allowed to click it. How can we determine in advance
 whether something will be allowed? This tag can also operate in an alternative mode which allows you to define a particular URL as
an attribute. If the user is allowed to invoke that URL, then the tag body will be evaluated, otherwise it will be skipped. 
So you might have something like

<sec:authorize url="/admin">

This content will only be visible to users who are authorized to send requests to the "/admin" URL.

</sec:authorize>
To use this tag there must also be an instance of WebInvocationPrivilegeEvaluator in your application context. If you are using 
the namespace, one will automatically be registered. This is an instance of DefaultWebInvocationPrivilegeEvaluator, 
which creates a dummy web request for the supplied URL and invokes the security interceptor to see whether the request 
would succeed or fail. This allows you to delegate to the access-control setup you defined using intercept-url declarations 
within the <http> namespace configuration and saves having to duplicate the information (such as the required roles) within 
your JSPs. This approach can also be combined with a method attribute, supplying the HTTP method, for a more specific match.

19.3 The authenticationTag

This tag allows access to the current Authentication object stored in the security context. It renders a property of the object 
directly in the JSP. So, for example, if the principal property of the Authentication is an instance of Spring Security's UserDetails 
object, then using <sec:authentication property="principal.username" /> will render the name of the current user.

Of course, it isn't necessary to use JSP tags for this kind of thing and some people prefer to keep as little logic as possible in 
the view. You can access the Authentication object in your MVC controller (by calling SecurityContextHolder.getContext().getAuthentication()) 
and add the data directly to your model for rendering by the view.

19.4 The accesscontrollist Tag

This tag is only valid when used with Spring Security's ACL module. It checks a comma-separated list of required permissions for a 
specified domain object. If the current user has any of those permissions, then the tag body will be evaluated. If they don't, 
it will be skipped. An example might be

<sec:accesscontrollist hasPermission="1,2" domainObject="someObject">

This will be shown if the user has either of the permissions 
represented by the values "1" or "2" on the given object.

</sec:accesscontrollist>
The permissions are passed to the PermissionFactory defined in the application context, converting them to ACL Permission instances, 
so they may be any format which is supported by the factory - they don't have to be integers, they could be strings like READ or WRITE. 
If no PermissionFactory is found, an instance of DefaultPermissionFactory will be used. The AclServicefrom the application context will
 be used to load the Acl instance for the supplied object. The Acl will be invoked with the required permissions to check if any of them 
 are granted.

--------------------------------------------------------Example of JSP Authentication /Authorize Taglib------------------------------------------------------------------------------------------------------------------

When this is the case, we can use the authorize tag:
 
<sec:authorize access="!isAuthenticated()">
  Login
</sec:authorize>
<sec:authorize access="isAuthenticated()">
  Logout
</sec:authorize>
Furthermore, we can check if an authenticated user has specific roles:
 
<sec:authorize access="hasRole('ADMIN')">
    Manage Users
</sec:authorize>
And we can use any Spring Security expression as our value for access:

hasAnyRole(‘ADMIN’,’USER’) returns true if the current user has any of the listed roles
isAnonymous() returns true if the current principal is an anonymous user
isRememberMe() returns true if the current principal is a remember-me user
isFullyAuthenticated() returns true if the user is authenticated and is neither anonymous nor a remember-me user
4.2. url

Other than that, we can check for users who are authorized to send requests to the certain URLs:
 
<sec:authorize url="/userManagement">
    <a href="/userManagement">Manage Users</a>
</sec:authorize>

-----------------------<sec:authentication property="principal"/> for UsernamePasswordAuthenticationToken ------------------------------

UsernamePasswordAuthenticationToken implements Authentication, so everything is correct. The only difference is that 
you have to use <sec:authentication property="principal"/> instead of <sec:authentication property="user.principal"/> 

public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {

	private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;

	// ~ Instance fields
	// ================================================================================================

	private final Object principal;
	private Object credentials;
	
	.....
	
	public abstract class AbstractAuthenticationToken implements Authentication,
		CredentialsContainer {
	// ~ Instance fields
	// ================================================================================================

	private final Collection<GrantedAuthority> authorities;
	
	<sec:authentication property="authorities"/>
	
--------------------------------------------------------Spring Web Database-------------------------------------------------------------------------------------------
	Demo 
	 @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    
    private String username;

    private String password;

    @Transient
    private String passwordConfirm;
    
    
    @ManyToMany (fetch = FetchType.EAGER)   // default Lazy loading but if lazy loading the session closed !!!
    private Set<Role> roles;
    .........
    }
    
    public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(mappedBy = "roles", fetch = FetchType.EAGER )
    private Set<User> users;
    ..........
    }
    
    (1) Ideally , we have ROLE_USER,ROLE_SUPER,ROLE_API,ROLE_ADMIN, we have to let user sign up anytime with basic ROLE_USER
    (2) Admin user has the authority to assign which user got ROLE_SUPER,ROLE_API,ROLE_ADMIN
    (3) 